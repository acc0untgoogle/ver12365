<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MiniStrike FF — Single File</title>
  <style>
    :root { --ui:#0b0d10; --fg:#e9eef2; --accent:#31d67b; }
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto;}
    #game{display:block;width:100%;height:100%;}
    #start{
      position:fixed;inset:auto 50% 40% 50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,.7);color:#fff;border:2px solid #fff;border-radius:12px;
      padding:14px 28px;font-size:18px;cursor:pointer;z-index:10;user-select:none;
    }
    #hud{
      position:fixed;inset:0 0 auto 0;display:none;z-index:10;color:var(--fg);
      pointer-events:none;font-weight:600;
    }
    #ammo{position:absolute;top:14px;left:16px;background:rgba(0,0,0,.45);padding:8px 12px;border-radius:10px}
    #health{position:absolute;top:14px;right:16px;background:rgba(0,0,0,.45);padding:8px 12px;border-radius:10px}
    #crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:22px;opacity:.8}
    #hint{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);opacity:.8;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:10px;font-size:12px}
    /* شاشة تحميل */
    #loading{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center;flex-direction:column;color:#fff;z-index:20}
    #barWrap{width:min(520px,80vw);height:14px;background:#222;border-radius:10px;overflow:hidden;margin-top:10px}
    #bar{height:100%;width:0;background:var(--accent);}
    /* وميض إطلاق */
    .muzzleFlash{position:fixed;width:100%;height:100%;inset:0;background:radial-gradient(circle at 50% 50%, rgba(255,236,150,.18), transparent 50%);opacity:0;transition:opacity .08s;pointer-events:none;z-index:5}
    .muzzleFlash.show{opacity:1}
  </style>
</head>
<body>
  <div id="start">انقر للعب</div>
  <div id="loading">
    <div id="loadText">جاري التحميل… 0%</div>
    <div id="barWrap"><div id="bar"></div></div>
  </div>
  <div id="hud">
    <div id="ammo">0/0</div>
    <div id="health">❤ 100</div>
    <div id="crosshair">+</div>
    <div id="hint">WASD حركة • Shift ركض • زر أيسر إطلاق • زر أيمن ADS • R إعادة التذخير • G وميض</div>
  </div>
  <div class="muzzleFlash" id="flash"></div>
  <canvas id="game"></canvas>

  <script type="module">
    // ===== Imports =====
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.155/examples/jsm/controls/PointerLockControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155/examples/jsm/loaders/FBXLoader.js';

    // ===== UI refs =====
    const canvas = document.getElementById('game');
    const startBtn = document.getElementById('start');
    const hud = document.getElementById('hud');
    const ammoEl = document.getElementById('ammo');
    const hpEl = document.getElementById('health');
    const loading = document.getElementById('loading');
    const loadText = document.getElementById('loadText');
    const bar = document.getElementById('bar');
    const flash = document.getElementById('flash');

    // ===== Scene setup =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101215);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, .1, 1000);
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, .65); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, .9); sun.position.set(15,25,10); sun.castShadow = true; scene.add(sun);

    // Controls / player
    const controls = new PointerLockControls(camera, canvas);
    camera.position.set(0, 1.7, 6);

    // ===== Loaders =====
    const manager = new THREE.LoadingManager();
    const gltf = new GLTFLoader(manager);
    const fbx = new FBXLoader(manager);

    manager.onProgress = (url, loaded, total) => {
      const pct = total ? Math.min(100, (loaded/total)*100) : 10;
      bar.style.width = pct.toFixed(0) + '%';
      loadText.textContent = `جاري التحميل… ${pct.toFixed(0)}%`;
    };

    // ===== Player state =====
    const keys = new Set();
    let running = false;
    let ads = false;
    let playerHP = 100;

    const playerObj = new THREE.Object3D(); // physics proxy
    playerObj.position.set(0, 1.0, 0);
    scene.add(playerObj);

    // ===== Weapon =====
    const weapon = {
      group: new THREE.Group(),
      muzzle: new THREE.Object3D(),
      damage: 25,
      fireRate: 9, // bullets per second
      clipSize: 30,
      reserve: 120,
      inClip: 30,
      reloading: false,
      lastShot: 0,
      adsFov: 55,
      hipFov: 75,
      load(url){
        return new Promise((resolve)=>{
          const ext = (url.split('.').pop()||'').toLowerCase();
          const on = (obj)=>{
            this.group.clear();
            const root = obj.scene || obj;
            root.traverse(o=>{ o.castShadow = true; });
            this.group.add(root);
            this.muzzle.position.set(0.12,-0.07,-0.6);
            this.group.add(this.muzzle);
            resolve();
          };
          (ext==='fbx'? fbx : gltf).load(url, on, undefined, _=>{
            // fallback weapon (box)
            const g = new THREE.Mesh(
              new THREE.BoxGeometry(.25,.12,.7),
              new THREE.MeshStandardMaterial({color:0x222222, metalness:.2, roughness:.6})
            );
            this.group.clear(); this.group.add(g);
            this.muzzle.position.set(0.12,-0.02,-0.35);
            this.group.add(this.muzzle);
            resolve();
          });
        });
      },
      update(dt){
        // simple sway
        const t = performance.now()*0.001;
        this.group.position.x = Math.sin(t*6)*0.003;
        this.group.position.y = Math.cos(t*8)*0.003;
        // ADS fov blend
        camera.fov += ((ads? this.adsFov : this.hipFov) - camera.fov) * 10*dt;
        camera.updateProjectionMatrix();
      },
      canShoot(){
        if(this.reloading || this.inClip<=0) return false;
        const now = performance.now()*0.001;
        return (now - this.lastShot) >= (1/this.fireRate);
      },
      shoot(origin, dir){
        this.lastShot = performance.now()*0.001;
        this.inClip--;
        updateAmmo();
        // recoil
        camera.rotation.x -= 0.01;
        // flash UI
        flash.classList.add('show'); setTimeout(()=>flash.classList.remove('show'), 50);
        // hitscan
        const hit = hitscan(origin, dir, 200);
        if(hit){
          spawnSpark(hit.point);
          const root = findDamageRoot(hit.object);
          if(root){ applyDamage(root, this.damage); }
        }
      },
      reload(){
        if(this.reloading || this.inClip===this.clipSize || this.reserve<=0) return;
        this.reloading = true;
        setTimeout(()=>{
          const need = this.clipSize - this.inClip;
          const take = Math.min(need, this.reserve);
          this.inClip += take; this.reserve -= take;
          updateAmmo();
          this.reloading = false;
        }, 900);
      }
    };
    function updateAmmo(){ ammoEl.textContent = `${weapon.inClip}/${weapon.reserve}`; }

    // Attach weapon to camera
    camera.add(weapon.group);
    weapon.group.position.set(0.25, -0.18, -0.4);
    weapon.group.rotation.set(0,0,0);

    // ===== Map load with fallback =====
    async function loadMap(){
      return new Promise((resolve)=>{
        gltf.load('assets/map.glb', (g)=>{
          g.scene.traverse(o=>{ o.receiveShadow = true; o.castShadow = !!o.castShadow; o.userData.static = true; });
          scene.add(g.scene);
          resolve(true);
        }, undefined, ()=>{
          // fallback map
          const floor = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({color:0x3c3c42}));
          floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);
          for(let i=0;i<10;i++){
            const b = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color:0x2a2f36}));
            b.position.set((Math.random()-0.5)*50,1,(Math.random()-0.5)*50);
            b.castShadow = b.receiveShadow = true;
            b.userData.hittable = true;
            scene.add(b);
          }
          resolve(false);
        });
      });
    }

    // ===== Bots (enemies) =====
    const bots = [];
    const botGeom = new THREE.CapsuleGeometry(0.4, 1.1, 6, 12);
    const botMat = new THREE.MeshStandardMaterial({color:0xc0392b});
    let botModel = null;

    function makeBotMesh(){
      if(botModel){
        const m = botModel.clone();
        m.traverse(o=>{ o.castShadow = true; });
        return m;
      }
      const m = new THREE.Mesh(botGeom, botMat);
      return m;
    }

    function spawnBot(pos){
      const root = new THREE.Object3D();
      const mesh = makeBotMesh();
      root.add(mesh);
      root.position.copy(pos);
      root.userData.hittable = true;
      root.userData.damageable = true;
      root.userData.health = 120; // أعداء أقوياء
      scene.add(root);
      bots.push({root, vel:new THREE.Vector3(), strafeSign: Math.random()<.5? -1:1, cooldown:0});
      return root;
    }

    function applyDamage(root, dmg){
      if(!root.userData.damageable) return;
      root.userData.health -= dmg;
      if(root.userData.health <= 0){
        // death
        spawnSpark(root.position);
        scene.remove(root);
        const i = bots.findIndex(b=>b.root===root);
        if(i>=0) bots.splice(i,1);
      }
    }

    function findDamageRoot(o){
      let cur = o;
      while(cur && !cur.userData.damageable && cur.parent) cur = cur.parent;
      return cur && cur.userData.damageable ? cur : null;
    }

    async function loadBotModel(){
      return new Promise((resolve)=>{
        fbx.load('assets/character.fbx', (obj)=>{
          botModel = obj;
          resolve();
        }, undefined, ()=> resolve()); // ignore errors (fallback capsule)
      });
    }

    // ===== Raycast / VFX =====
    const ray = new THREE.Raycaster();
    function hitscan(origin, dir, dist=200){
      ray.set(origin, dir.normalize());
      ray.far = dist;
      const hits = ray.intersectObjects(scene.children, true);
      return hits.find(h=>h.object && h.object !== weapon.group);
    }
    const sparkGeo = new THREE.SphereGeometry(0.03, 6, 6);
    const sparkMat = new THREE.MeshBasicMaterial({color:0xffffaa});
    function spawnSpark(point){
      const m = new THREE.Mesh(sparkGeo, sparkMat);
      m.position.copy(point);
      scene.add(m);
      setTimeout(()=>scene.remove(m), 120);
    }

    // ===== Input =====
    addEventListener('keydown', e=>{
      if(e.code==='KeyG'){ flash.classList.add('show'); setTimeout(()=>flash.classList.remove('show'),60); }
      if(e.code==='KeyR'){ weapon.reload(); }
      if(e.code==='ShiftLeft'){ running = true; }
      keys.add(e.code);
    });
    addEventListener('keyup', e=>{
      if(e.code==='ShiftLeft'){ running = false; }
      keys.delete(e.code);
    });

    let mouseDown = false;
    addEventListener('mousedown', e=>{
      if(e.button===0){ mouseDown = true; }
      if(e.button===2){ ads = true; }
    });
    addEventListener('mouseup', e=>{
      if(e.button===0){ mouseDown = false; }
      if(e.button===2){ ads = false; }
    });
    addEventListener('contextmenu', e=>e.preventDefault()); // disable default menu

    // ===== Game loop =====
    const clock = new THREE.Clock();
    function update(dt){
      // player kinematics (very light fake physics)
      const speed = (running? 7.5 : 4.0);
      const dir = new THREE.Vector3();
      const fwd = new THREE.Vector3();
      controls.getDirection(fwd); fwd.y = 0; fwd.normalize();
      const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).negate();

      if(keys.has('KeyW')) dir.add(fwd);
      if(keys.has('KeyS')) dir.sub(fwd);
      if(keys.has('KeyA')) dir.sub(right);
      if(keys.has('KeyD')) dir.add(right);

      dir.normalize().multiplyScalar(speed*dt);
      playerObj.position.add(dir);
      camera.position.set(playerObj.position.x, 1.7, playerObj.position.z);

      // shooting
      if(mouseDown && weapon.canShoot()){
        const origin = camera.getWorldPosition(new THREE.Vector3());
        const to = camera.getWorldDirection(new THREE.Vector3());
        weapon.shoot(origin, to);
      }

      // weapon update
      weapon.update(dt);

      // bots AI: seek + strafe + separation + stop when close
      const toPlayer = new THREE.Vector3();
      for(const b of bots){
        toPlayer.copy(playerObj.position).sub(b.root.position);
        const dist = toPlayer.length();
        toPlayer.normalize();

        // Separation
        const sep = new THREE.Vector3();
        for(const other of bots){
          if(other===b) continue;
          const d = b.root.position.distanceTo(other.root.position);
          if(d<2){ sep.add(new THREE.Vector3().subVectors(b.root.position, other.root.position).normalize().multiplyScalar(1.5/d)); }
        }

        // strafe
        const rightV = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), toPlayer).normalize().multiplyScalar(0.6*b.strafeSign);

        // final vel
        const targetV = new THREE.Vector3();
        if(dist>3) targetV.add(toPlayer.multiplyScalar( (dist>15)? 6.0 : 3.5 ));
        targetV.add(rightV).add(sep);
        b.vel.lerp(targetV, 3*dt);
        b.root.position.addScaledVector(b.vel, dt);

        // face player
        b.root.lookAt(playerObj.position.x, b.root.position.y, playerObj.position.z);

        // attack if close (melee)
        b.cooldown -= dt;
        if(dist<2 && b.cooldown<=0){
          damagePlayer(18);
          b.cooldown = 0.9;
        }
      }
    }

    function damagePlayer(dmg){
      playerHP = Math.max(0, playerHP - dmg);
      hpEl.textContent = `❤ ${playerHP}`;
      if(playerHP<=0){
        // simple respawn
        playerHP = 100; hpEl.textContent = '❤ 100';
        playerObj.position.set(0,1,0);
      }
    }

    function loop(){
      requestAnimationFrame(loop);
      const dt = Math.min(clock.getDelta(), 0.05);
      update(dt);
      renderer.render(scene, camera);
    }

    // ===== Start flow =====
    startBtn.addEventListener('click', async ()=>{
      startBtn.style.display = 'none';
      loading.style.display = 'flex';

      // queue critical loads
      const tasks = [
        loadMap(),
        weapon.load('assets/weapon.fbx'),
        loadBotModel()
      ];
      await Promise.all(tasks);

      // spawn enemies
      for(let i=0;i<6;i++){
        const angle = (i/6)*Math.PI*2;
        const r = 12 + Math.random()*8;
        spawnBot(new THREE.Vector3(Math.cos(angle)*r, 0, Math.sin(angle)*r));
      }

      hud.style.display = 'block';
      controls.lock();
      loading.style.display = 'none';
      updateAmmo();
      loop();
    });

    controls.addEventListener('unlock', ()=>{
      // show start again as pause
      startBtn.textContent = 'متابعة';
      startBtn.style.display = 'block';
      hud.style.display = 'none';
    });
    controls.addEventListener('lock', ()=>{
      startBtn.style.display = 'none';
      hud.style.display = 'block';
    });

    // ===== Resize =====
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
